@page "/"

@using Microsoft.CodeAnalysis
@using Microsoft.CodeAnalysis.CSharp
@using Microsoft.CodeAnalysis.CSharp.Scripting.Hosting
@using System.Reflection
@using System.IO
@using System.Threading
@using System.Web

@inject IJSRuntime JSRuntime
@inject IJSUnmarshalledRuntime JSUnmarshalledRuntime
@inject NavigationManager MyNavigationManager

<div class=grid>
    <button class="run" @onclick="Run">Run</button>
    <div id="editor">@csharp</div>
    <div id="model"></div>
    <div class="output">@((MarkupString)output)</div>
</div>

@code {
    private bool isFirstLoad = true;
    private static string csharp = @"var model = new Model();

var length = 10;

Validator.DisableValidationOnConstruction = true;
var m = BuiltInMaterials.Concrete;
var wf = new WideFlangeProfileFactory();
var p = wf.GetProfileByType(WideFlangeProfileType.W10x100);

for(var i=0; i<1; i++)
{
    var start = new Vector3(i, 0, 0);
    var end = new Vector3(i, length, i);

    // The bottom chord
    var bottomChord = new Line(start, end);
    var bottomChordBeam = new Beam(bottomChord, p, m);
    model.AddElement(bottomChordBeam);

    var topChord = new Line(start + new Vector3(0,0,5), end + new Vector3(0,0,5));
    var topChordBeam = new Beam(topChord, p, m);
    model.AddElement(topChordBeam);

    Vector3 last = default(Vector3);
    for(var j=0.0; j<=1.0; j+=0.1)
    {
        var pt = bottomChord.PointAt(j);
        var top = pt + new Vector3(0,0,5);
        var panelLine = new Line(pt, top);
        var panelBeam = new Beam(panelLine, p, m);
        model.AddElement(panelBeam);

        if(j > 0.0)
        {
            var braceLine = new Line(top, last);
            var braceBeam = new Beam(braceLine, p, m);
            model.AddElement(braceBeam);
        }
        last = pt;
    }
}
return model;";
    private string output = "";
    private List<MetadataReference> references;
    private Func<object[], Task> submission;

    protected override async Task OnInitializedAsync()
    {
        // Create instances of model and Console
        // to ensure they're loaded in the app domain.
        var model = new Elements.Model();
        Console.WriteLine("");

        var refs = AppDomain.CurrentDomain.GetAssemblies();
        var client = new HttpClient
        {
            BaseAddress = new Uri(MyNavigationManager.BaseUri)
        };

        var listRefs = new List<MetadataReference>();

        foreach (var reference in refs.Where(x => !x.IsDynamic)) // && !string.IsNullOrWhiteSpace(x.Location)))
        {
            var location = $"_framework/{reference.GetName().Name}.dll";
            var stream = await client.GetStreamAsync(location);
            listRefs.Add(MetadataReference.CreateFromStream(stream));
        }

        references = listRefs;
    }

    private async Task RunAsync(ChangeEventArgs args)
    {
        try
        {
            var model = await (Task<object>)submission(new object[] { null, null });
            await Task.Run(() =>
            {
                var glb = ((Elements.Model)model).ToGlTF();
                JSUnmarshalledRuntime.InvokeUnmarshalled<byte[], bool>("model.loadModel", glb);
            });
        }
        catch(Exception ex)
        {
            output += $@"<div class=""message"">Run failed.</div>";
            output += $@"<div class=""message"">{ex.Message}</div>";
            @* output += $@"<div class=""error"">{ex.StackTrace}</div>\n"; *@
            @* output += $@"<div class=""error"">{ex.InnerException}</div>\n"; *@
        }
    }

    private async Task Run()
    {
        if(EvaluateAsync(csharp))
        {
            await RunAsync(null);
        }
    }

    private bool EvaluateAsync(string code)
    {
        output = "";
        var previousOut = Console.Out;
        try
        {
            if (TryCompile(code, out var compilation, out var script, out var errorDiagnostics))
            {
                var entryPoint = compilation.GetEntryPoint(CancellationToken.None);
                var type = script.GetType($"{entryPoint.ContainingNamespace.MetadataName}.{entryPoint.ContainingType.MetadataName}");
                var entryPointMethod = type.GetMethod(entryPoint.MetadataName);

                output += $@"<div class=""success"">Compilation was successful.</div>";
                output += $@"<br>";

                submission = (Func<object[], Task>)entryPointMethod.CreateDelegate(typeof(Func<object[], Task>));

                return true;
            }
            else
            {
                output += $@"<div class=""error"">Compilation failed.</div>";
                output += $@"<br>";

                foreach (var diag in errorDiagnostics)
                {
                    output += $@"<div class=""message"">{HttpUtility.HtmlEncode(diag)}</div>";
                }
                return false;
            }
        }
        catch (Exception ex)
        {
            output += $@"<div class=""message"">{ex.Message}</div>";
            output += $@"<div class=""message"">{ex.StackTrace}</div>";
            output += $@"<div class=""message"">{ex.InnerException}</div>";
            return false;
        }
        finally
        {
            Console.SetOut(previousOut);
        }
    }

    private bool TryCompile(string source, out CSharpCompilation compilation, out Assembly assembly, out
    List<Diagnostic> errorDiagnostics)
    {
        assembly = null;
        compilation = null;

        // Use ConcurrentBuild to avoid the issue in
        // TODO: https://github.com/dotnet/runtime/issues/43411
        var scriptCompilation = CSharpCompilation.CreateScriptCompilation(
        Path.GetRandomFileName(),
        CSharpSyntaxTree.ParseText(source,
        CSharpParseOptions.Default.WithKind(SourceCodeKind.Script).WithLanguageVersion(LanguageVersion.Preview)),
        references,
        new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary, usings: new[]
        {
"System",
"System.Collections.Generic",
"System.Console",
"System.Linq",
"Elements",
"Elements.Geometry",
"Elements.Geometry.Profiles",
"Elements.Validators"
        }, concurrentBuild: false));

        errorDiagnostics = scriptCompilation.GetDiagnostics().Where(x => x.Severity == DiagnosticSeverity.Error).ToList();
        if (errorDiagnostics.Any())
        {
            return false;
        }

        using (var peStream = new MemoryStream())
        {
            var emitResult = scriptCompilation.Emit(peStream);

            if (emitResult.Success)
            {
                compilation = scriptCompilation;
                assembly = Assembly.Load(peStream.ToArray());
                return true;
            }
        }

        return false;
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (isFirstLoad)
        {
            isFirstLoad = false;
            await JSRuntime.InvokeVoidAsync("model.initializeEditor");
            await JSRuntime.InvokeVoidAsync("model.initialize3D");
        }
    }

    [JSInvokable]
    public static void SetCodeValue(string code)
    {
        csharp = code;
    }
}